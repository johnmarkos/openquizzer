<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>OpenQuizzer</title>
    <meta
      name="description"
      content="A fast, mobile-friendly quiz app. Edit config.js and add content JSON files to make it yours."
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <meta name="color-scheme" content="light dark" />
    <style>
      :root {
        --bg: #0d1117;
        --bg-secondary: #161b22;
        --border: #30363d;
        --text: #c9d1d9;
        --text-muted: #8b949e;
        --accent: #58a6ff;
        --accent-alpha: rgba(88, 166, 255, 0.1);
        --success: #3fb950;
        --success-alpha: rgba(63, 185, 80, 0.1);
        --error: #f85149;
        --error-alpha: rgba(248, 81, 73, 0.1);
      }

      @media (prefers-color-scheme: light) {
        :root {
          --bg: #ffffff;
          --bg-secondary: #f6f8fa;
          --border: #d0d7de;
          --text: #1f2328;
          --text-muted: #656d76;
          --accent: #0969da;
          --accent-alpha: rgba(9, 105, 218, 0.1);
          --success: #1a7f37;
          --success-alpha: rgba(26, 127, 55, 0.1);
          --error: #cf222e;
          --error-alpha: rgba(207, 34, 46, 0.1);
        }
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html {
        font-size: 16px;
      }

      body {
        background-color: var(--bg);
        color: var(--text);
        font-family:
          "JetBrains Mono", "SF Mono", "Fira Code", "Consolas", monospace;
        line-height: 1.6;
        min-height: 100vh;
        min-height: 100dvh;
        padding: 1rem;
      }

      .container {
        max-width: 600px;
        margin: 0 auto;
      }

      /* Header */
      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding-bottom: 1rem;
        border-bottom: 1px solid var(--border);
        margin-bottom: 1rem;
      }

      .header h1 {
        font-size: 0.875rem;
        font-weight: 600;
      }

      .header-right {
        display: flex;
        align-items: center;
        gap: 1rem;
      }

      .progress {
        font-size: 0.75rem;
        color: var(--text-muted);
      }

      /* Landing view */
      .landing {
        padding: 1rem 0;
      }

      .landing h2 {
        font-size: 1.25rem;
        margin-bottom: 0.5rem;
      }

      .landing p {
        color: var(--text-muted);
        font-size: 0.875rem;
        margin-bottom: 1.5rem;
      }

      .unit-list {
        list-style: none;
      }

      .unit-item {
        margin-bottom: 1rem;
      }

      .unit-title {
        font-size: 0.875rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
        color: var(--text-muted);
      }

      .chapter-list {
        list-style: none;
      }

      .chapter-btn {
        display: block;
        width: 100%;
        text-align: left;
        padding: 0.75rem 1rem;
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 6px;
        color: var(--text);
        font-family: inherit;
        font-size: 0.875rem;
        cursor: pointer;
        margin-bottom: 0.5rem;
        transition: border-color 0.15s;
      }

      .chapter-btn:hover:not(:disabled) {
        border-color: var(--accent);
      }

      .chapter-btn:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      .chapter-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .chapter-btn.loading {
        opacity: 0.7;
        cursor: wait;
      }

      .chapter-btn.practice-all-btn {
        background: var(--accent-alpha);
        border-color: var(--accent);
        font-weight: 500;
      }

      /* Practice view */
      .practice {
        display: none;
      }

      .practice.active {
        display: block;
      }

      .landing.hidden {
        display: none;
      }

      .chapter-header {
        font-size: 0.75rem;
        color: var(--text-muted);
        margin-bottom: 1.5rem;
      }

      .problem-id {
        display: none;
        font-size: 0.7rem;
        opacity: 0.35;
        margin-bottom: 0.25rem;
        user-select: all;
      }

      .question {
        font-size: 1rem;
        margin-bottom: 1.5rem;
        line-height: 1.5;
      }

      .options {
        list-style: none;
        margin-bottom: 1rem;
      }

      .option-btn {
        display: block;
        width: 100%;
        text-align: left;
        padding: 0.875rem 1rem;
        background: var(--bg-secondary);
        border: 2px solid var(--border);
        border-radius: 6px;
        color: var(--text);
        font-family: inherit;
        font-size: 0.875rem;
        cursor: pointer;
        margin-bottom: 0.5rem;
        transition:
          border-color 0.15s,
          background-color 0.15s;
      }

      .option-btn:hover:not(:disabled) {
        border-color: var(--accent);
      }

      .option-btn:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      .option-btn:disabled {
        cursor: default;
      }

      .option-btn.correct {
        border-color: var(--success);
        background: var(--success-alpha);
      }

      .option-btn.incorrect {
        border-color: var(--error);
        background: var(--error-alpha);
      }

      /* Feedback */
      .feedback {
        display: none;
        padding: 1rem;
        border-radius: 6px;
        margin-bottom: 1rem;
        font-size: 0.875rem;
        line-height: 1.5;
      }

      .feedback.visible {
        display: block;
      }

      .feedback.correct {
        background: var(--success-alpha);
        border: 1px solid var(--success);
      }

      .feedback.incorrect {
        background: var(--error-alpha);
        border: 1px solid var(--error);
      }

      .feedback-title {
        font-weight: 600;
        margin-bottom: 0.5rem;
      }

      .feedback.correct .feedback-title {
        color: var(--success);
      }

      .feedback.incorrect .feedback-title {
        color: var(--error);
      }

      .detail-toggle {
        display: inline-block;
        background: none;
        border: none;
        color: var(--accent);
        font-family: inherit;
        font-size: 0.8rem;
        cursor: pointer;
        padding: 0;
        margin-top: 0.5rem;
      }

      .detail-toggle:hover {
        text-decoration: underline;
      }

      .detail-toggle:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      .feedback-detail {
        margin-top: 0.5rem;
        padding-top: 0.5rem;
        border-top: 1px solid var(--border);
        font-size: 0.8rem;
        line-height: 1.5;
        color: var(--text);
      }

      .feedback-detail a {
        color: var(--accent);
      }

      .references-list {
        list-style: none;
        margin-top: 0.5rem;
        padding: 0;
      }

      .references-list li {
        padding: 0.125rem 0;
      }

      .references-list a {
        color: var(--accent);
        font-size: 0.8rem;
      }

      /* Error message */
      .error-msg {
        display: none;
        padding: 1rem;
        border-radius: 6px;
        margin-bottom: 1rem;
        font-size: 0.875rem;
        background: var(--error-alpha);
        border: 1px solid var(--error);
        color: var(--error);
      }

      .error-msg.visible {
        display: block;
      }

      /* Navigation */
      .nav-btn {
        display: inline-block;
        padding: 0.75rem 1.5rem;
        background: var(--accent);
        border: none;
        border-radius: 6px;
        color: #fff;
        font-family: inherit;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: opacity 0.15s;
      }

      .nav-btn:hover {
        opacity: 0.9;
      }

      .nav-btn:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      .nav-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .nav-btn.secondary {
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        color: var(--text);
      }

      .nav-btn.hidden {
        display: none;
      }

      .nav-row {
        display: flex;
        gap: 0.5rem;
        margin-top: 1rem;
      }

      .nav-row.results-nav {
        justify-content: center;
      }

      /* Results view */
      .results {
        display: none;
        text-align: center;
        padding: 2rem 0;
      }

      .results.active {
        display: block;
      }

      .results h2 {
        font-size: 1.25rem;
        margin-bottom: 1rem;
      }

      .score {
        font-size: 3rem;
        font-weight: 600;
        color: var(--accent);
        margin-bottom: 0.5rem;
      }

      .score-label {
        color: var(--text-muted);
        font-size: 0.875rem;
        margin-bottom: 2rem;
      }

      .results-export {
        margin-bottom: 1.25rem;
        padding: 0.875rem;
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 6px;
        text-align: left;
      }

      .results-export-actions {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .results-export-status {
        min-height: 1.25rem;
        margin-top: 0.5rem;
        font-size: 0.75rem;
        color: var(--text-muted);
      }

      .results-summary {
        margin-top: 0.5rem;
        padding: 0.75rem;
        border-radius: 6px;
        border: 1px solid var(--border);
        background: var(--bg);
        font-size: 0.75rem;
        line-height: 1.5;
        white-space: pre-wrap;
        max-height: 220px;
        overflow: auto;
      }

      /* Breakdown sections */
      .results-breakdown {
        text-align: left;
        margin-bottom: 1.25rem;
        padding: 0.875rem;
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 6px;
      }

      .breakdown-section {
        margin-bottom: 0.75rem;
      }

      .breakdown-section:last-child {
        margin-bottom: 0;
      }

      .breakdown-heading {
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--text-muted);
        margin-bottom: 0.375rem;
      }

      .breakdown-row {
        display: flex;
        justify-content: space-between;
        font-size: 0.8rem;
        padding: 0.125rem 0;
      }

      .breakdown-label {
        color: var(--text);
      }

      .breakdown-stats {
        color: var(--text-muted);
      }

      /* Quit link in practice mode */
      .quit-link {
        color: var(--text-muted);
        text-decoration: none;
        font-size: 0.75rem;
        cursor: pointer;
        background: none;
        border: none;
        font-family: inherit;
        padding: 0;
      }

      .quit-link:hover {
        color: var(--error);
      }

      .quit-link:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      /* Back link */
      .back-link {
        display: inline-block;
        color: var(--text-muted);
        text-decoration: none;
        font-size: 0.75rem;
        margin-bottom: 1rem;
      }

      .back-link:hover {
        color: var(--accent);
      }

      .back-link:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      /* Hidden utility class */
      .hidden-container {
        display: none !important;
      }

      /* Numeric input */
      .numeric-input-container {
        margin-bottom: 1rem;
      }

      .numeric-input-row {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      .numeric-input {
        flex: 1;
        padding: 0.875rem 1rem;
        background: var(--bg-secondary);
        border: 2px solid var(--border);
        border-radius: 6px;
        color: var(--text);
        font-family: inherit;
        font-size: 1rem;
        min-width: 0;
      }

      .numeric-input:focus {
        outline: none;
        border-color: var(--accent);
      }

      .numeric-input:disabled {
        opacity: 0.7;
      }

      .numeric-input.correct {
        border-color: var(--success);
        background: var(--success-alpha);
      }

      .numeric-input.incorrect {
        border-color: var(--error);
        background: var(--error-alpha);
      }

      .numeric-unit {
        color: var(--text-muted);
        font-size: 0.875rem;
        white-space: nowrap;
      }

      .submit-btn {
        padding: 0.875rem 1.5rem;
        background: var(--accent);
        border: none;
        border-radius: 6px;
        color: #fff;
        font-family: inherit;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        white-space: nowrap;
      }

      .submit-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* Multi-select */
      .multi-select-hint {
        color: var(--text-muted);
        font-size: 0.75rem;
        margin-bottom: 0.75rem;
      }

      .option-btn.multi-select {
        position: relative;
        padding-left: 2.5rem;
      }

      .option-btn.multi-select::before {
        content: "";
        position: absolute;
        left: 0.875rem;
        top: 50%;
        transform: translateY(-50%);
        width: 18px;
        height: 18px;
        border: 2px solid var(--border);
        border-radius: 4px;
        background: var(--bg);
      }

      .option-btn.multi-select.selected::before {
        background: var(--accent);
        border-color: var(--accent);
      }

      .option-btn.multi-select.selected::after {
        content: "\2713";
        position: absolute;
        left: 0.95rem;
        top: 50%;
        transform: translateY(-50%);
        color: #fff;
        font-size: 0.75rem;
        font-weight: bold;
      }

      .option-btn.multi-select.correct-selected::before {
        background: var(--success);
        border-color: var(--success);
      }

      .option-btn.multi-select.correct-missed {
        border-color: var(--success);
      }

      .option-btn.multi-select.correct-missed::before {
        border-color: var(--success);
      }

      .option-btn.multi-select.incorrect-selected::before {
        background: var(--error);
        border-color: var(--error);
      }

      .multi-submit-row {
        margin-top: 0.5rem;
      }

      /* Ordering */
      .ordering-container {
        margin-bottom: 1rem;
      }

      .ordering-hint {
        color: var(--text-muted);
        font-size: 0.75rem;
        margin-bottom: 0.75rem;
      }

      .ordering-item {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.875rem 1rem;
        background: var(--bg-secondary);
        border: 2px solid var(--border);
        border-radius: 6px;
        margin-bottom: 0.5rem;
        cursor: pointer;
        transition:
          border-color 0.15s,
          transform 0.1s;
        user-select: none;
      }

      .ordering-item:hover:not(.disabled) {
        border-color: var(--accent);
      }

      .ordering-item.selected {
        border-color: var(--accent);
        background: var(--accent-alpha);
      }

      .ordering-item.disabled {
        cursor: default;
      }

      .ordering-item.correct-position {
        border-color: var(--success);
        background: var(--success-alpha);
      }

      .ordering-item.incorrect-position {
        border-color: var(--error);
        background: var(--error-alpha);
      }

      .ordering-rank {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: var(--border);
        color: var(--text);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.75rem;
        font-weight: 600;
        flex-shrink: 0;
      }

      .ordering-item.selected .ordering-rank {
        background: var(--accent);
        color: #fff;
      }

      .ordering-item.correct-position .ordering-rank {
        background: var(--success);
      }

      .ordering-item.incorrect-position .ordering-rank {
        background: var(--error);
      }

      .ordering-text {
        flex: 1;
        font-size: 0.875rem;
      }

      /* Two-stage */
      .stage-indicator {
        display: inline-block;
        padding: 0.25rem 0.5rem;
        background: var(--accent-alpha);
        border: 1px solid var(--accent);
        border-radius: 4px;
        font-size: 0.7rem;
        color: var(--accent);
        margin-bottom: 0.75rem;
      }

      .stage-context {
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 6px;
        padding: 0.75rem 1rem;
        margin-bottom: 1rem;
        font-size: 0.8rem;
      }

      .stage-context-label {
        color: var(--text-muted);
        font-size: 0.7rem;
        margin-bottom: 0.25rem;
      }

      /* Correct answer display */
      .correct-answer-display {
        margin-top: 0.5rem;
        padding: 0.5rem 0.75rem;
        background: var(--success-alpha);
        border: 1px solid var(--success);
        border-radius: 4px;
        font-size: 0.8rem;
      }

      .correct-answer-label {
        color: var(--success);
        font-weight: 600;
        margin-right: 0.5rem;
      }

      /* History section on landing */
      .history-section {
        margin-top: 1.5rem;
        padding: 0.875rem;
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 6px;
      }

      .history-header {
        margin-bottom: 0.5rem;
      }

      .history-summary-text {
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .history-actions {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      /* Import area */
      .import-area {
        margin-top: 0.75rem;
      }

      .import-textarea {
        width: 100%;
        padding: 0.75rem;
        background: var(--bg-secondary);
        border: 2px solid var(--border);
        border-radius: 6px;
        color: var(--text);
        font-family: inherit;
        font-size: 0.8rem;
        resize: vertical;
        min-height: 100px;
      }

      .import-textarea:focus {
        outline: none;
        border-color: var(--accent);
      }

      .import-actions {
        display: flex;
        gap: 0.5rem;
        margin-top: 0.5rem;
      }

      .import-status {
        min-height: 1.25rem;
        margin-top: 0.5rem;
        font-size: 0.75rem;
        color: var(--text-muted);
      }

      /* Dashboard view */
      .dashboard {
        display: none;
        padding: 1rem 0;
      }

      .dashboard.active {
        display: block;
      }

      .dashboard h2 {
        font-size: 1.25rem;
        margin-bottom: 1rem;
      }

      .dashboard-overview {
        font-size: 0.875rem;
        color: var(--text-muted);
        margin-bottom: 1.5rem;
        padding: 0.875rem;
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 6px;
      }

      .dashboard-section {
        margin-bottom: 1.25rem;
        padding: 0.875rem;
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 6px;
      }

      .dashboard-actions {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        margin-top: 1rem;
      }

      /* Timer display */
      .timer-display {
        font-variant-numeric: tabular-nums;
        font-size: 0.875rem;
        color: var(--text-muted);
        font-weight: 500;
      }

      .timer-warning {
        color: var(--error);
      }

      /* Resume prompt */
      .resume-prompt {
        margin-bottom: 1.25rem;
        padding: 0.875rem;
        background: var(--bg-secondary);
        border: 1px solid var(--accent);
        border-radius: 6px;
        font-size: 0.875rem;
      }

      .resume-prompt p {
        color: var(--text);
        margin-bottom: 0.75rem;
      }

      .resume-prompt-actions {
        display: flex;
        gap: 0.5rem;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <div id="back-link-container"></div>

      <!-- Landing View -->
      <div id="landing" class="landing">
        <h2 id="landing-title"></h2>
        <p id="landing-description"></p>

        <div id="error-msg" class="error-msg"></div>

        <div id="unit-list"></div>
        <div id="resume-prompt" class="resume-prompt hidden-container">
          <p id="resume-prompt-text">Resume your previous session?</p>
          <div class="resume-prompt-actions">
            <button class="nav-btn" id="resume-yes-btn">Resume</button>
            <button class="nav-btn secondary" id="resume-no-btn">
              Start Fresh
            </button>
          </div>
        </div>
        <div id="history-section" class="history-section hidden-container">
          <div class="history-header">
            <span id="history-summary-text" class="history-summary-text"></span>
          </div>
          <div class="history-actions">
            <button class="nav-btn secondary" id="dashboard-btn">
              View Dashboard
            </button>
            <button class="nav-btn secondary" id="load-history-btn">
              Import History
            </button>
          </div>
        </div>
        <div id="import-area" class="import-area hidden-container">
          <textarea
            id="import-textarea"
            class="import-textarea"
            placeholder="Paste session JSON here (single object or array)..."
            rows="6"
          ></textarea>
          <div class="import-actions">
            <button class="nav-btn" id="import-submit-btn">Import</button>
            <button class="nav-btn secondary" id="import-cancel-btn">
              Cancel
            </button>
          </div>
          <div id="import-status" class="import-status"></div>
        </div>
      </div>

      <!-- Practice View -->
      <div id="practice" class="practice">
        <header class="header">
          <h1 id="practice-title"></h1>
          <div class="header-right">
            <span
              id="timer-display"
              class="timer-display hidden-container"
            ></span>
            <span class="progress" id="progress" aria-label="Question 1 of 10"
              ><span id="current">1</span>/<span id="total">10</span></span
            >
            <button class="quit-link" id="quit-btn" aria-label="Quit session">
              &times; Quit
            </button>
          </div>
        </header>

        <div class="chapter-header" id="chapter-desc"></div>

        <div id="question-container">
          <div
            id="stage-indicator"
            class="stage-indicator hidden-container"
          ></div>
          <div id="stage-context" class="stage-context hidden-container">
            <div class="stage-context-label">Your previous answer:</div>
            <div id="stage-context-text"></div>
          </div>
          <span class="problem-id" id="problem-id"></span>
          <p class="question" id="question-text"></p>

          <!-- Multiple choice options -->
          <ul class="options" id="options"></ul>

          <!-- Numeric input -->
          <div
            id="numeric-container"
            class="numeric-input-container hidden-container"
          >
            <div class="numeric-input-row">
              <input
                type="text"
                inputmode="decimal"
                id="numeric-input"
                class="numeric-input"
                placeholder="Enter number..."
                autocomplete="off"
              />
              <span class="numeric-unit" id="numeric-unit"></span>
              <button class="submit-btn" id="numeric-submit">Submit</button>
            </div>
            <div
              id="correct-answer-display"
              class="correct-answer-display hidden-container"
            >
              <span class="correct-answer-label">Correct:</span>
              <span id="correct-answer-value"></span>
            </div>
          </div>

          <!-- Ordering -->
          <div
            id="ordering-container"
            class="ordering-container hidden-container"
          >
            <div class="ordering-hint">
              Tap to select, then tap another to swap. Use Arrow keys to
              reorder.
            </div>
            <div id="ordering-items"></div>
            <button class="submit-btn" id="ordering-submit">
              Submit Order
            </button>
          </div>

          <!-- Multi-select submit -->
          <div
            id="multi-submit-container"
            class="multi-submit-row hidden-container"
          >
            <button class="submit-btn" id="multi-submit">
              Submit Selection
            </button>
          </div>

          <div class="feedback" id="feedback" aria-live="polite">
            <div class="feedback-title" id="feedback-title"></div>
            <div id="feedback-explanation"></div>
            <button
              id="feedback-detail-toggle"
              class="detail-toggle hidden-container"
            >
              Learn more
            </button>
            <div
              id="feedback-detail"
              class="feedback-detail hidden-container"
            ></div>
          </div>

          <div class="nav-row">
            <button class="nav-btn secondary hidden" id="skip-btn">Skip</button>
            <button class="nav-btn hidden" id="next-btn">Next</button>
          </div>
        </div>
      </div>

      <!-- Results View -->
      <div id="results" class="results">
        <h2>Session Complete</h2>
        <div class="score" id="score">0%</div>
        <div class="score-label">
          <span id="correct-count">0</span> of
          <span id="total-count">0</span> correct
        </div>
        <div
          id="session-status-label"
          class="score-label hidden-container"
        ></div>
        <div id="skipped-label" class="score-label hidden-container"></div>
        <div id="timed-out-label" class="score-label hidden-container"></div>
        <div id="results-breakdown" class="results-breakdown hidden-container">
          <div id="type-breakdown" class="breakdown-section"></div>
          <div id="tag-breakdown" class="breakdown-section"></div>
        </div>
        <div class="results-export">
          <div class="results-export-actions">
            <button class="nav-btn secondary" id="copy-json-btn">
              Copy JSON
            </button>
            <button class="nav-btn secondary" id="show-summary-btn">
              Show Summary
            </button>
          </div>
          <div id="results-export-status" class="results-export-status"></div>
          <pre
            id="results-summary"
            class="results-summary hidden-container"
          ></pre>
        </div>
        <div class="nav-row results-nav">
          <button class="nav-btn secondary" id="retry-btn">Try Again</button>
          <button class="nav-btn secondary hidden" id="results-dashboard-btn">
            View Dashboard
          </button>
          <button class="nav-btn" id="back-btn">Back to Menu</button>
        </div>
      </div>
      <!-- Dashboard View -->
      <div id="dashboard" class="dashboard">
        <button class="quit-link" id="dashboard-back-btn">
          &larr; Back to Menu
        </button>
        <h2>Progress Dashboard</h2>
        <div id="dashboard-overview" class="dashboard-overview"></div>
        <div
          id="dashboard-trend"
          class="dashboard-section hidden-container"
        ></div>
        <div
          id="dashboard-by-type"
          class="dashboard-section hidden-container"
        ></div>
        <div
          id="dashboard-by-tag"
          class="dashboard-section hidden-container"
        ></div>
        <div
          id="dashboard-by-unit"
          class="dashboard-section hidden-container"
        ></div>
        <div
          id="dashboard-most-missed"
          class="dashboard-section hidden-container"
        ></div>
        <div class="dashboard-actions">
          <button class="nav-btn secondary" id="export-all-btn">
            Export All History
          </button>
          <button class="nav-btn secondary" id="clear-history-btn">
            Clear History
          </button>
        </div>
        <div id="dashboard-export-status" class="results-export-status"></div>
      </div>
    </div>

    <script type="module">
      import {
        OpenQuizzer,
        validateSessionSummary,
        deduplicateSessions,
        computeAggregateStats,
        updateProblemTracking,
        computeProficiency,
        computeWeakestAreas,
        computeSRWeights,
      } from "./openquizzer.js";
      import { CONFIG } from "./config.js";

      const quiz = new OpenQuizzer();

      const UNITS = CONFIG.units;

      // =============================================
      // Constants & DOM element references
      // =============================================

      const TWO_STAGE_TRANSITION_DELAY = 800; // ms pause between two-stage parts
      const TIME_LIMIT = CONFIG.timeLimit || 0; // seconds per question (0 = disabled)

      // Top-level views
      const landing = document.getElementById("landing");
      const practice = document.getElementById("practice");
      const results = document.getElementById("results");
      const errorMsg = document.getElementById("error-msg");

      // Practice view — header & progress
      const practiceTitle = document.getElementById("practice-title");
      const chapterDesc = document.getElementById("chapter-desc");
      const currentEl = document.getElementById("current");
      const totalEl = document.getElementById("total");
      const progressEl = document.getElementById("progress");
      const quitBtn = document.getElementById("quit-btn");

      // Practice view — question area
      const problemIdEl = document.getElementById("problem-id");
      const questionText = document.getElementById("question-text");
      const optionsEl = document.getElementById("options");
      const feedback = document.getElementById("feedback");
      const feedbackTitle = document.getElementById("feedback-title");
      const feedbackExplanation = document.getElementById(
        "feedback-explanation",
      );
      const feedbackDetailToggle = document.getElementById(
        "feedback-detail-toggle",
      );
      const feedbackDetail = document.getElementById("feedback-detail");
      const nextBtn = document.getElementById("next-btn");
      const skipBtn = document.getElementById("skip-btn");
      const multiSubmit = document.getElementById("multi-submit");

      // Numeric input elements
      const numericContainer = document.getElementById("numeric-container");
      const numericInput = document.getElementById("numeric-input");
      const numericUnit = document.getElementById("numeric-unit");
      const numericSubmit = document.getElementById("numeric-submit");
      const correctAnswerDisplay = document.getElementById(
        "correct-answer-display",
      );
      const correctAnswerValue = document.getElementById(
        "correct-answer-value",
      );

      // Ordering elements
      const orderingContainer = document.getElementById("ordering-container");
      const orderingItems = document.getElementById("ordering-items");
      const orderingSubmit = document.getElementById("ordering-submit");

      // Results view elements
      const scoreEl = document.getElementById("score");
      const correctCountEl = document.getElementById("correct-count");
      const totalCountEl = document.getElementById("total-count");
      const sessionStatusLabel = document.getElementById(
        "session-status-label",
      );
      const retryBtn = document.getElementById("retry-btn");
      const backBtn = document.getElementById("back-btn");
      const copyJsonBtn = document.getElementById("copy-json-btn");
      const showSummaryBtn = document.getElementById("show-summary-btn");
      const resultsExportStatus = document.getElementById(
        "results-export-status",
      );
      const resultsSummary = document.getElementById("results-summary");

      // Results breakdown elements
      const skippedLabel = document.getElementById("skipped-label");
      const resultsBreakdown = document.getElementById("results-breakdown");
      const typeBreakdownEl = document.getElementById("type-breakdown");
      const tagBreakdownEl = document.getElementById("tag-breakdown");

      // Multi-select elements
      const multiSubmitContainer = document.getElementById(
        "multi-submit-container",
      );

      // Two-stage elements
      const stageIndicator = document.getElementById("stage-indicator");
      const stageContext = document.getElementById("stage-context");
      const stageContextText = document.getElementById("stage-context-text");

      // Dashboard view elements
      const dashboardEl = document.getElementById("dashboard");
      const dashboardOverview = document.getElementById("dashboard-overview");
      const dashboardTrend = document.getElementById("dashboard-trend");
      const dashboardByType = document.getElementById("dashboard-by-type");
      const dashboardByTag = document.getElementById("dashboard-by-tag");
      const dashboardByUnit = document.getElementById("dashboard-by-unit");
      const dashboardMostMissed = document.getElementById(
        "dashboard-most-missed",
      );
      const dashboardBackBtn = document.getElementById("dashboard-back-btn");
      const exportAllBtn = document.getElementById("export-all-btn");
      const clearHistoryBtn = document.getElementById("clear-history-btn");
      const dashboardExportStatus = document.getElementById(
        "dashboard-export-status",
      );
      const resultsDashboardBtn = document.getElementById(
        "results-dashboard-btn",
      );

      // History section elements
      const historySection = document.getElementById("history-section");
      const historySummaryText = document.getElementById(
        "history-summary-text",
      );
      const dashboardBtn = document.getElementById("dashboard-btn");
      const loadHistoryBtn = document.getElementById("load-history-btn");
      const importArea = document.getElementById("import-area");
      const importTextarea = document.getElementById("import-textarea");
      const importSubmitBtn = document.getElementById("import-submit-btn");
      const importCancelBtn = document.getElementById("import-cancel-btn");
      const importStatus = document.getElementById("import-status");

      // Timer elements
      const timerDisplay = document.getElementById("timer-display");
      const timedOutLabel = document.getElementById("timed-out-label");

      // Resume elements
      const resumePrompt = document.getElementById("resume-prompt");
      const resumePromptText = document.getElementById("resume-prompt-text");
      const resumeYesBtn = document.getElementById("resume-yes-btn");
      const resumeNoBtn = document.getElementById("resume-no-btn");

      let selectedOrderingIndex = -1; // -1 means nothing selected
      let latestSessionSummary = null;
      let sessionHistory = [];
      let timerInterval = null;
      let timerSecondsLeft = 0;
      let problemTracking = {};
      let allProblemsById = {}; // { [id]: { id, question, tags, type } } for weakest-areas

      // =============================================
      // UI helpers
      // =============================================

      function showError(message) {
        errorMsg.textContent = message;
        errorMsg.classList.add("visible");
      }

      function hideError() {
        errorMsg.classList.remove("visible");
      }

      function hideAllQuestionTypes() {
        optionsEl.classList.add("hidden-container");
        numericContainer.classList.add("hidden-container");
        orderingContainer.classList.add("hidden-container");
        multiSubmitContainer.classList.add("hidden-container");
        stageIndicator.classList.add("hidden-container");
        stageContext.classList.add("hidden-container");
        correctAnswerDisplay.classList.add("hidden-container");
      }

      // =============================================
      // Timer functions
      // =============================================

      function startTimer() {
        clearTimer();
        if (TIME_LIMIT <= 0) return;
        timerSecondsLeft = TIME_LIMIT;
        timerDisplay.classList.remove("hidden-container", "timer-warning");
        timerDisplay.textContent = formatTimerDisplay(timerSecondsLeft);

        timerInterval = setInterval(() => {
          timerSecondsLeft--;
          timerDisplay.textContent = formatTimerDisplay(timerSecondsLeft);

          // Warning at 25% time remaining
          if (timerSecondsLeft <= Math.ceil(TIME_LIMIT * 0.25)) {
            timerDisplay.classList.add("timer-warning");
          }

          if (timerSecondsLeft <= 0) {
            clearTimer();
            quiz.timeout();
          }
        }, 1000);
      }

      function clearTimer() {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
        timerDisplay.classList.add("hidden-container");
        timerDisplay.classList.remove("timer-warning");
      }

      function formatTimerDisplay(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return mins > 0
          ? `${mins}:${String(secs).padStart(2, "0")}`
          : `${secs}s`;
      }

      // =============================================
      // Landing page rendering
      // =============================================

      function renderUnitList() {
        const container = document.getElementById("unit-list");
        const ul = document.createElement("ul");
        ul.className = "unit-list";

        UNITS.forEach((unit) => {
          const li = document.createElement("li");
          li.className = "unit-item";

          const title = document.createElement("div");
          title.className = "unit-title";
          title.textContent = `Unit ${unit.id}: ${unit.title}`;
          li.appendChild(title);

          const chapterUl = document.createElement("ul");
          chapterUl.className = "chapter-list";

          const readyChapters = unit.chapters.filter((c) => c.ready);
          if (readyChapters.length > 1) {
            const allLi = document.createElement("li");
            const allBtn = document.createElement("button");
            allBtn.className = "chapter-btn practice-all-btn";
            allBtn.dataset.unit = unit.id;
            allBtn.textContent = `\u25b6 Practice All ${unit.title} (${readyChapters.length} chapters)`;
            allBtn.addEventListener("click", () => loadUnit(unit.id, allBtn));
            allLi.appendChild(allBtn);
            chapterUl.appendChild(allLi);
          }

          unit.chapters.forEach((chapter) => {
            const chapterLi = document.createElement("li");
            const btn = document.createElement("button");
            btn.className = "chapter-btn";

            if (chapter.ready) {
              btn.dataset.chapter = `unit-${unit.id}-chapter-${chapter.num}`;
              btn.textContent = `${chapter.num}. ${chapter.title}`;
              btn.addEventListener("click", () =>
                loadChapter(btn.dataset.chapter, btn),
              );
            } else {
              btn.disabled = true;
              btn.textContent = `${chapter.num}. ${chapter.title} (coming soon)`;
            }

            chapterLi.appendChild(btn);
            chapterUl.appendChild(chapterLi);
          });

          li.appendChild(chapterUl);
          ul.appendChild(li);
        });

        container.appendChild(ul);
      }

      // =============================================
      // Content loading
      // =============================================

      async function loadUnit(unitId, buttonEl) {
        if (buttonEl.disabled) return;

        hideError();
        const originalText = buttonEl.textContent;
        buttonEl.dataset.originalText = originalText;
        buttonEl.disabled = true;
        buttonEl.classList.add("loading");
        buttonEl.textContent = "Loading...";

        const unit = UNITS.find((u) => u.id === unitId);
        const readyChapters = unit.chapters.filter((c) => c.ready);

        try {
          const chapterPromises = readyChapters.map((c) =>
            fetch(`content/unit-${unitId}-chapter-${c.num}.json`).then((r) => {
              if (!r.ok) throw new Error(`Failed to load chapter ${c.num}`);
              return r.json();
            }),
          );

          const chapters = await Promise.all(chapterPromises);
          const allProblems = chapters.flatMap((ch) => ch.problems);

          // Collect problem metadata for weakest-areas dashboard
          for (const p of allProblems) {
            allProblemsById[p.id] = {
              id: p.id,
              question: p.question || "",
              tags: p.tags || [],
              type: p.type || "multiple-choice",
            };
          }

          const chapterTitle = `All ${unit.title}`;
          const chapterDescription = `${allProblems.length} problems from ${readyChapters.length} chapters`;

          quiz.loadProblems(
            allProblems,
            CONFIG.maxProblems,
            {
              unitTitle: unit.title,
              unitId: unit.id,
              practiceAll: true,
            },
            problemTracking,
          );
          startPractice(chapterTitle, chapterDescription);
        } catch (err) {
          console.error("Failed to load unit:", err);
          showError("Failed to load unit. Please try again.");
          buttonEl.textContent = originalText;
          buttonEl.disabled = false;
        } finally {
          buttonEl.classList.remove("loading");
        }
      }

      async function loadChapter(chapterId, buttonEl) {
        if (buttonEl.disabled) return;

        hideError();
        const originalText = buttonEl.textContent;
        buttonEl.dataset.originalText = originalText;
        buttonEl.disabled = true;
        buttonEl.classList.add("loading");
        buttonEl.textContent = "Loading...";

        try {
          const response = await fetch(`content/${chapterId}.json`);
          if (!response.ok) {
            throw new Error(`Failed to load (${response.status})`);
          }
          const data = await response.json();

          // Collect problem metadata for weakest-areas dashboard
          for (const p of data.problems) {
            allProblemsById[p.id] = {
              id: p.id,
              question: p.question || "",
              tags: p.tags || [],
              type: p.type || "multiple-choice",
            };
          }

          // Extract unit/chapter IDs from the "unit-N-chapter-M" string
          const match = chapterId.match(/unit-(\d+)-chapter-(\d+)/);
          const unitId = match ? parseInt(match[1]) : null;
          const unit = unitId ? UNITS.find((u) => u.id === unitId) : null;

          quiz.loadProblems(
            data.problems,
            0,
            {
              chapterTitle: data.chapterTitle,
              unitTitle: unit ? unit.title : "",
              unitId: unitId,
              chapterNum: match ? parseInt(match[2]) : null,
            },
            problemTracking,
          );
          startPractice(data.chapterTitle, data.chapterDescription);
        } catch (err) {
          console.error("Failed to load chapter:", err);
          showError("Failed to load chapter. Please try again.");
          buttonEl.textContent = originalText;
          buttonEl.disabled = false;
        } finally {
          buttonEl.classList.remove("loading");
        }
      }

      // =============================================
      // View transitions
      // =============================================

      function startPractice(title, description) {
        landing.classList.add("hidden");
        results.classList.remove("active");
        practice.classList.add("active");

        practiceTitle.textContent = title;
        chapterDesc.textContent = description;

        quiz.start();
      }

      function backToMenu() {
        clearTimer();
        clearInProgressSnapshot();
        practice.classList.remove("active");
        results.classList.remove("active");
        dashboardEl.classList.remove("active");
        landing.classList.remove("hidden");

        quiz.reset();
        resultsDashboardBtn.classList.add("hidden");
        importArea.classList.add("hidden-container");

        document
          .querySelectorAll(".chapter-btn[data-original-text]")
          .forEach((btn) => {
            btn.textContent = btn.dataset.originalText;
            btn.disabled = false;
            btn.classList.remove("loading");
          });

        renderHistorySummary();
        window.scrollTo(0, 0);
      }

      // =============================================
      // Question type renderers
      // =============================================

      function renderMultipleChoiceQuestion(problem) {
        questionText.textContent = problem.question;
        optionsEl.classList.remove("hidden-container");
        optionsEl.innerHTML = "";

        problem.options.forEach((option, index) => {
          const li = document.createElement("li");
          const btn = document.createElement("button");
          btn.className = "option-btn";
          btn.textContent = option;
          btn.dataset.index = index;
          btn.dataset.type = "multiple-choice";
          li.appendChild(btn);
          optionsEl.appendChild(li);
        });
      }

      function renderNumericQuestion(problem) {
        questionText.textContent = problem.question;
        numericContainer.classList.remove("hidden-container");
        numericInput.value = "";
        numericInput.disabled = false;
        numericInput.classList.remove("correct", "incorrect");
        numericSubmit.disabled = false;
        numericUnit.textContent = problem.unit || "";
        correctAnswerDisplay.classList.add("hidden-container");
        numericInput.focus();
      }

      function renderMultiSelectQuestion(problem) {
        questionText.textContent = problem.question;
        optionsEl.classList.remove("hidden-container");
        multiSubmitContainer.classList.remove("hidden-container");
        multiSubmit.disabled = false;
        optionsEl.innerHTML = "";

        const hint = document.createElement("li");
        hint.innerHTML =
          '<div class="multi-select-hint">Select all that apply</div>';
        optionsEl.appendChild(hint);

        problem.options.forEach((option, index) => {
          const li = document.createElement("li");
          const btn = document.createElement("button");
          btn.className = "option-btn multi-select";
          btn.textContent = option;
          btn.dataset.index = index;
          btn.dataset.type = "multi-select";
          btn.setAttribute("aria-pressed", "false");
          li.appendChild(btn);
          optionsEl.appendChild(li);
        });
      }

      function renderTwoStageQuestion(problem, stageIndex, previousAnswer) {
        const stage = problem.stages[stageIndex];

        stageIndicator.classList.remove("hidden-container");
        stageIndicator.textContent = `Part ${stageIndex + 1} of ${problem.stages.length}`;

        if (stageIndex > 0 && previousAnswer != null) {
          stageContext.classList.remove("hidden-container");
          stageContextText.textContent = previousAnswer;
        } else {
          stageContext.classList.add("hidden-container");
        }

        questionText.textContent = stage.question;
        optionsEl.classList.remove("hidden-container");
        optionsEl.innerHTML = "";

        stage.options.forEach((option, index) => {
          const li = document.createElement("li");
          const btn = document.createElement("button");
          btn.className = "option-btn";
          btn.textContent = option;
          btn.dataset.index = index;
          btn.dataset.type = "two-stage";
          btn.dataset.stage = stageIndex;
          li.appendChild(btn);
          optionsEl.appendChild(li);
        });
      }

      // =============================================
      // Feedback display
      // =============================================

      function showFeedback(
        isCorrect,
        explanation,
        detailedExplanation,
        references,
      ) {
        feedback.classList.add("visible");
        feedback.classList.add(isCorrect ? "correct" : "incorrect");
        feedbackTitle.textContent = isCorrect ? "Correct!" : "Incorrect";
        feedbackExplanation.textContent = explanation;

        // Reset detailed explanation state
        feedbackDetail.classList.add("hidden-container");
        feedbackDetail.innerHTML = "";
        feedbackDetailToggle.classList.add("hidden-container");
        feedbackDetailToggle.textContent = "Learn more";
        feedbackDetailToggle.onclick = null;

        const hasDetail =
          detailedExplanation || (references && references.length > 0);

        if (hasDetail) {
          feedbackDetailToggle.classList.remove("hidden-container");
          feedbackDetailToggle.onclick = () => {
            const isHidden =
              feedbackDetail.classList.contains("hidden-container");
            if (isHidden) {
              let html = detailedExplanation || "";
              if (references && references.length > 0) {
                html += '<ul class="references-list">';
                for (const ref of references) {
                  html += `<li><a href="${ref.url}" target="_blank" rel="noopener">${ref.title}</a></li>`;
                }
                html += "</ul>";
              }
              feedbackDetail.innerHTML = html;
              feedbackDetail.classList.remove("hidden-container");
              feedbackDetailToggle.textContent = "Show less";
            } else {
              feedbackDetail.classList.add("hidden-container");
              feedbackDetailToggle.textContent = "Learn more";
            }
          };
        }

        skipBtn.classList.add("hidden");
        const { current, total } = quiz.progress;
        nextBtn.classList.remove("hidden");
        nextBtn.textContent = current < total ? "Next" : "See Results";
        nextBtn.focus();
      }

      // =============================================
      // Export helpers
      // =============================================

      function buildSummaryText(summary) {
        if (!summary || !summary.score || !Array.isArray(summary.results)) {
          return "No session results available.";
        }

        const skippedNote =
          summary.score.skipped > 0
            ? ` (${summary.score.skipped} skipped)`
            : "";
        const header = `Score: ${summary.score.correct}/${summary.score.total} (${summary.score.percentage}%)${skippedNote}`;
        if (summary.results.length === 0) {
          return [header, "", "(No answered questions yet.)"].join("\n");
        }

        const lines = summary.results.map((result, index) => {
          const verdict = result.skipped
            ? "Skipped"
            : result.correct
              ? "Correct"
              : "Incorrect";
          const questionLabel = result.question ? ` ${result.question}` : "";
          return `${index + 1}. [${verdict}] (${result.type})${questionLabel}`;
        });

        const sections = [header, "", ...lines];

        // Type breakdown
        if (summary.breakdownByType) {
          const types = Object.entries(summary.breakdownByType);
          if (types.length > 0) {
            sections.push("", "By question type:");
            for (const [type, stats] of types) {
              sections.push(
                `  ${type}  ${stats.percentage}%  (${stats.correct}/${stats.total})`,
              );
            }
          }
        }

        // Tag breakdown
        if (summary.breakdownByTag) {
          const tags = Object.entries(summary.breakdownByTag);
          if (tags.length > 0) {
            sections.push("", "By topic:");
            for (const [tag, stats] of tags) {
              sections.push(
                `  ${tag}  ${stats.percentage}%  (${stats.correct}/${stats.total})`,
              );
            }
          }
        }

        return sections.join("\n");
      }

      function setResultsExportStatus(message) {
        resultsExportStatus.textContent = message || "";
      }

      async function copySummaryJsonToClipboard() {
        if (!latestSessionSummary) {
          setResultsExportStatus("No session results available to export yet.");
          return;
        }

        const jsonText = JSON.stringify(latestSessionSummary, null, 2);

        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(jsonText);
            setResultsExportStatus("Copied JSON to clipboard.");
            return;
          }
        } catch (error) {
          // Fall through to execCommand fallback.
        }

        const tempTextArea = document.createElement("textarea");
        tempTextArea.value = jsonText;
        tempTextArea.setAttribute("readonly", "true");
        tempTextArea.style.position = "absolute";
        tempTextArea.style.left = "-9999px";
        document.body.appendChild(tempTextArea);
        tempTextArea.select();

        const didCopy = document.execCommand("copy");
        document.body.removeChild(tempTextArea);
        setResultsExportStatus(
          didCopy
            ? "Copied JSON to clipboard."
            : "Could not copy automatically. Please copy manually.",
        );
      }

      function toggleSummaryView() {
        const isHidden = resultsSummary.classList.contains("hidden-container");
        if (isHidden) {
          resultsSummary.textContent = buildSummaryText(latestSessionSummary);
          resultsSummary.classList.remove("hidden-container");
          showSummaryBtn.textContent = "Hide Summary";
        } else {
          resultsSummary.classList.add("hidden-container");
          showSummaryBtn.textContent = "Show Summary";
        }
      }

      function renderBreakdownSection(targetEl, heading, data) {
        targetEl.innerHTML = "";
        const entries = Object.entries(data || {});
        if (entries.length === 0) return;

        const headingEl = document.createElement("div");
        headingEl.className = "breakdown-heading";
        headingEl.textContent = heading;
        targetEl.appendChild(headingEl);

        for (const [name, stats] of entries) {
          const row = document.createElement("div");
          row.className = "breakdown-row";
          const label = document.createElement("span");
          label.className = "breakdown-label";
          label.textContent = name;
          const statsSpan = document.createElement("span");
          statsSpan.className = "breakdown-stats";
          statsSpan.textContent = `${stats.percentage}% (${stats.correct}/${stats.total})`;
          row.appendChild(label);
          row.appendChild(statsSpan);
          targetEl.appendChild(row);
        }
      }

      function renderTypeBreakdown(breakdownByType) {
        renderBreakdownSection(
          typeBreakdownEl,
          "By question type",
          breakdownByType,
        );
      }

      function renderTagBreakdown(breakdownByTag) {
        renderBreakdownSection(tagBreakdownEl, "By topic", breakdownByTag);
      }

      function showResultsView({
        summary,
        isPartial,
        answeredCount,
        totalProblems,
      }) {
        if (!summary || !summary.score) return;

        latestSessionSummary = summary;
        scoreEl.textContent = `${summary.score.percentage}%`;
        correctCountEl.textContent = String(summary.score.correct);
        totalCountEl.textContent = String(summary.score.total);
        if (isPartial) {
          sessionStatusLabel.textContent = `Partial session: answered ${answeredCount} of ${totalProblems}`;
          sessionStatusLabel.classList.remove("hidden-container");
        } else {
          sessionStatusLabel.textContent = "";
          sessionStatusLabel.classList.add("hidden-container");
        }

        // Skipped count
        if (summary.score.skipped > 0) {
          skippedLabel.textContent = `${summary.score.skipped} skipped`;
          skippedLabel.classList.remove("hidden-container");
        } else {
          skippedLabel.textContent = "";
          skippedLabel.classList.add("hidden-container");
        }

        // Timed out count
        if (summary.score.timedOut > 0) {
          timedOutLabel.textContent = `${summary.score.timedOut} timed out`;
          timedOutLabel.classList.remove("hidden-container");
        } else {
          timedOutLabel.textContent = "";
          timedOutLabel.classList.add("hidden-container");
        }

        // Breakdowns
        renderTypeBreakdown(summary.breakdownByType);
        renderTagBreakdown(summary.breakdownByTag);
        const hasBreakdowns =
          Object.keys(summary.breakdownByType || {}).length > 0 ||
          Object.keys(summary.breakdownByTag || {}).length > 0;
        if (hasBreakdowns) {
          resultsBreakdown.classList.remove("hidden-container");
        } else {
          resultsBreakdown.classList.add("hidden-container");
        }

        resultsSummary.classList.add("hidden-container");
        showSummaryBtn.textContent = "Show Summary";
        setResultsExportStatus("");
        practice.classList.remove("active");
        results.classList.add("active");
      }

      function renderOrderingQuestion(problem, shuffledItems) {
        questionText.textContent = problem.question;
        orderingContainer.classList.remove("hidden-container");
        orderingSubmit.disabled = false;
        orderingItems.innerHTML = "";
        selectedOrderingIndex = -1;

        shuffledItems.forEach(({ originalIndex, text }, visualIndex) => {
          const div = document.createElement("div");
          div.className = "ordering-item";
          div.dataset.originalIndex = originalIndex;
          div.dataset.visualIndex = visualIndex; // track current position
          div.tabIndex = 0; // Make focusable
          div.setAttribute("role", "button"); // Semantic role
          div.setAttribute("aria-pressed", "false");

          const rank = document.createElement("span");
          rank.className = "ordering-rank";
          rank.textContent = visualIndex + 1;

          const textSpan = document.createElement("span");
          textSpan.className = "ordering-text";
          textSpan.textContent = text;

          div.appendChild(rank);
          div.appendChild(textSpan);
          orderingItems.appendChild(div);
        });
      }

      function updateOrderingDisplay(order) {
        // Re-render items in new order
        // We need to map originalIndex -> text from current DOM or problem?
        // Actually, easiest is to just re-append elements in new order

        const currentElements = Array.from(orderingItems.children);
        const map = new Map();
        currentElements.forEach((el) =>
          map.set(parseInt(el.dataset.originalIndex), el),
        );

        orderingItems.innerHTML = "";
        order.forEach((originalIndex, i) => {
          const el = map.get(originalIndex);
          if (el) {
            el.dataset.visualIndex = i;
            el.querySelector(".ordering-rank").textContent = i + 1;
            orderingItems.appendChild(el);
          }
        });

        // Re-apply selection state if needed
        if (selectedOrderingIndex !== -1) {
          const selectedEl = orderingItems.children[selectedOrderingIndex];
          if (selectedEl) {
            selectedEl.classList.add("selected");
            selectedEl.setAttribute("aria-pressed", "true");
            selectedEl.focus();
          }
        }
      }

      // =============================================
      // localStorage integration
      // =============================================

      function loadFromLocalStorage() {
        try {
          const key = CONFIG.storageKey || "openquizzer-sessions";
          const raw = localStorage.getItem(key);
          if (!raw) return [];
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return [];
          return parsed.filter((s) => validateSessionSummary(s).valid);
        } catch {
          return [];
        }
      }

      function saveToLocalStorage() {
        try {
          const key = CONFIG.storageKey || "openquizzer-sessions";
          localStorage.setItem(key, JSON.stringify(sessionHistory));
        } catch {
          /* quota exceeded or disabled — silent fail */
        }
      }

      function clearLocalStorage() {
        try {
          const key = CONFIG.storageKey || "openquizzer-sessions";
          localStorage.removeItem(key);
        } catch {
          /* silent */
        }
      }

      // =============================================
      // In-progress snapshot persistence
      // =============================================

      function loadInProgressSnapshot() {
        try {
          const key =
            (CONFIG.storageKey || "openquizzer-sessions") + "-in-progress";
          const raw = localStorage.getItem(key);
          if (!raw) return null;
          return JSON.parse(raw);
        } catch {
          return null;
        }
      }

      function saveInProgressSnapshot(snapshot) {
        try {
          const key =
            (CONFIG.storageKey || "openquizzer-sessions") + "-in-progress";
          localStorage.setItem(key, JSON.stringify(snapshot));
        } catch {
          /* quota exceeded or disabled — silent fail */
        }
      }

      function clearInProgressSnapshot() {
        try {
          const key =
            (CONFIG.storageKey || "openquizzer-sessions") + "-in-progress";
          localStorage.removeItem(key);
        } catch {
          /* silent */
        }
      }

      // =============================================
      // Per-problem tracking persistence
      // =============================================

      function loadProblemTracking() {
        try {
          const key =
            (CONFIG.storageKey || "openquizzer-sessions") + "-tracking";
          const raw = localStorage.getItem(key);
          if (!raw) return {};
          return JSON.parse(raw) || {};
        } catch {
          return {};
        }
      }

      function saveProblemTracking() {
        try {
          const key =
            (CONFIG.storageKey || "openquizzer-sessions") + "-tracking";
          localStorage.setItem(key, JSON.stringify(problemTracking));
        } catch {
          /* quota exceeded or disabled — silent fail */
        }
      }

      function clearProblemTracking() {
        try {
          const key =
            (CONFIG.storageKey || "openquizzer-sessions") + "-tracking";
          localStorage.removeItem(key);
        } catch {
          /* silent */
        }
      }

      // =============================================
      // History section rendering
      // =============================================

      function renderHistorySummary() {
        if (sessionHistory.length === 0) {
          historySection.classList.add("hidden-container");
          return;
        }
        const stats = computeAggregateStats(sessionHistory);
        historySummaryText.textContent = `${stats.sessionCount} session${stats.sessionCount !== 1 ? "s" : ""} \u00b7 ${stats.totalAnswered} question${stats.totalAnswered !== 1 ? "s" : ""} \u00b7 ${stats.overallPercentage}% overall`;
        historySection.classList.remove("hidden-container");
      }

      // =============================================
      // Paste import flow
      // =============================================

      function loadHistoryFromPaste(jsonString) {
        let parsed;
        try {
          parsed = JSON.parse(jsonString);
        } catch {
          return { imported: 0, errors: ["Invalid JSON — could not parse."] };
        }

        const items = Array.isArray(parsed) ? parsed : [parsed];
        const validItems = [];
        const errors = [];

        items.forEach((item, i) => {
          const result = validateSessionSummary(item);
          if (result.valid) {
            validItems.push(item);
          } else {
            errors.push(`Item ${i + 1}: ${result.errors.join(", ")}`);
          }
        });

        const before = sessionHistory.length;
        sessionHistory = deduplicateSessions([
          ...sessionHistory,
          ...validItems,
        ]);
        const newCount = sessionHistory.length - before;
        saveToLocalStorage();
        renderHistorySummary();

        return { imported: newCount, errors };
      }

      // =============================================
      // Dashboard view
      // =============================================

      function renderTrendSection(trend, sessions) {
        if (trend.length === 0) {
          dashboardTrend.classList.add("hidden-container");
          return;
        }
        dashboardTrend.classList.remove("hidden-container");
        dashboardTrend.innerHTML = "";

        const heading = document.createElement("div");
        heading.className = "breakdown-heading";
        heading.textContent = "Recent sessions";
        dashboardTrend.appendChild(heading);

        // Build a map from timestamp to session context for labels
        const contextMap = new Map();
        for (const session of sessions) {
          if (session.context) {
            contextMap.set(session.timestamp, session.context);
          }
        }

        // Show last 10, most recent first
        const recent = trend.slice(-10).reverse();
        for (const entry of recent) {
          const row = document.createElement("div");
          row.className = "breakdown-row";

          const label = document.createElement("span");
          label.className = "breakdown-label";
          const date = new Date(entry.timestamp);
          const dateStr = date.toLocaleDateString("en-US", {
            month: "short",
            day: "numeric",
          });
          const ctx = contextMap.get(entry.timestamp);
          const contextLabel =
            ctx && ctx.chapterTitle
              ? ctx.chapterTitle
              : ctx && ctx.unitTitle
                ? ctx.unitTitle
                : "";
          label.textContent = contextLabel
            ? `${dateStr}  ${contextLabel}`
            : dateStr;

          const stats = document.createElement("span");
          stats.className = "breakdown-stats";
          stats.textContent = `${entry.percentage}%  (${entry.correct}/${entry.total})`;

          row.appendChild(label);
          row.appendChild(stats);
          dashboardTrend.appendChild(row);
        }
      }

      function renderWeakestAreas() {
        const weakest = computeWeakestAreas(
          problemTracking,
          allProblemsById,
          10,
          new Date(),
        );
        if (weakest.length === 0) {
          dashboardMostMissed.classList.add("hidden-container");
          return;
        }
        dashboardMostMissed.classList.remove("hidden-container");
        dashboardMostMissed.innerHTML = "";

        const heading = document.createElement("div");
        heading.className = "breakdown-heading";
        heading.textContent = "Weakest areas";
        dashboardMostMissed.appendChild(heading);

        for (const item of weakest) {
          const row = document.createElement("div");
          row.className = "breakdown-row";

          const label = document.createElement("span");
          label.className = "breakdown-label";
          const questionPreview =
            item.question.length > 60
              ? item.question.slice(0, 57) + "..."
              : item.question;
          label.textContent = `${item.id}: ${questionPreview}`;

          const stats = document.createElement("span");
          stats.className = "breakdown-stats";
          const pct = Math.round(item.proficiency * 100);
          stats.textContent = `${pct}% proficiency (${item.correct}/${item.seen})`;

          row.appendChild(label);
          row.appendChild(stats);
          dashboardMostMissed.appendChild(row);
        }
      }

      function renderDashboard() {
        const stats = computeAggregateStats(sessionHistory);

        // Overview
        let overviewText = `${stats.sessionCount} session${stats.sessionCount !== 1 ? "s" : ""} \u00b7 ${stats.totalAnswered} question${stats.totalAnswered !== 1 ? "s" : ""} \u00b7 ${stats.overallPercentage}% overall`;
        if (stats.totalSkipped > 0) {
          overviewText += ` \u00b7 ${stats.totalSkipped} skipped`;
        }
        dashboardOverview.textContent = overviewText;

        // Trend
        renderTrendSection(stats.trend, sessionHistory);

        // By type
        if (Object.keys(stats.byType).length > 0) {
          dashboardByType.classList.remove("hidden-container");
          renderBreakdownSection(
            dashboardByType,
            "By question type",
            stats.byType,
          );
        } else {
          dashboardByType.classList.add("hidden-container");
        }

        // By tag
        if (Object.keys(stats.byTag).length > 0) {
          dashboardByTag.classList.remove("hidden-container");
          renderBreakdownSection(dashboardByTag, "By topic", stats.byTag);
        } else {
          dashboardByTag.classList.add("hidden-container");
        }

        // By unit
        if (Object.keys(stats.byUnit).length > 0) {
          dashboardByUnit.classList.remove("hidden-container");
          renderBreakdownSection(dashboardByUnit, "By unit", stats.byUnit);
        } else {
          dashboardByUnit.classList.add("hidden-container");
        }

        // Weakest areas (proficiency-aware, replaces most missed)
        renderWeakestAreas();

        dashboardExportStatus.textContent = "";
      }

      function showDashboard() {
        landing.classList.add("hidden");
        results.classList.remove("active");
        practice.classList.remove("active");
        dashboardEl.classList.add("active");
        renderDashboard();
        window.scrollTo(0, 0);
      }

      function hideDashboard() {
        dashboardEl.classList.remove("active");
        landing.classList.remove("hidden");
        renderHistorySummary();
        window.scrollTo(0, 0);
      }

      async function exportAllHistory() {
        if (sessionHistory.length === 0) {
          dashboardExportStatus.textContent = "No history to export.";
          return;
        }

        const jsonText = JSON.stringify(sessionHistory, null, 2);

        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(jsonText);
            dashboardExportStatus.textContent = `Copied ${sessionHistory.length} session${sessionHistory.length !== 1 ? "s" : ""} to clipboard.`;
            return;
          }
        } catch {
          // Fall through to execCommand fallback.
        }

        const tempTextArea = document.createElement("textarea");
        tempTextArea.value = jsonText;
        tempTextArea.setAttribute("readonly", "true");
        tempTextArea.style.position = "absolute";
        tempTextArea.style.left = "-9999px";
        document.body.appendChild(tempTextArea);
        tempTextArea.select();

        const didCopy = document.execCommand("copy");
        document.body.removeChild(tempTextArea);
        dashboardExportStatus.textContent = didCopy
          ? `Copied ${sessionHistory.length} session${sessionHistory.length !== 1 ? "s" : ""} to clipboard.`
          : "Could not copy automatically.";
      }

      function clearHistory() {
        if (!confirm("Clear all session history? This cannot be undone.")) {
          return;
        }
        sessionHistory = [];
        problemTracking = {};
        clearLocalStorage();
        clearInProgressSnapshot();
        clearProblemTracking();
        hideDashboard();
      }

      // =============================================
      // Engine event listeners
      // =============================================

      quiz.on(
        "questionShow",
        ({ problem, index, total, type, shuffledItems }) => {
          hideAllQuestionTypes();
          optionsEl.innerHTML = "";

          feedback.classList.remove("visible", "correct", "incorrect");
          nextBtn.classList.add("hidden");
          skipBtn.classList.remove("hidden");

          currentEl.textContent = index + 1;
          totalEl.textContent = total;
          progressEl.setAttribute(
            "aria-label",
            `Question ${index + 1} of ${total}`,
          );

          // Show problem ID if enabled via config (for issue reporting)
          if (CONFIG.showProblemId && problem.id) {
            problemIdEl.textContent = problem.id;
            problemIdEl.style.display = "block";
          } else {
            problemIdEl.style.display = "none";
          }

          if (type === "two-stage") {
            renderTwoStageQuestion(problem, 0, null);
          } else if (type === "numeric-input") {
            renderNumericQuestion(problem);
          } else if (type === "ordering") {
            renderOrderingQuestion(problem, shuffledItems);
          } else if (type === "multi-select") {
            renderMultiSelectQuestion(problem);
          } else {
            renderMultipleChoiceQuestion(problem);
          }

          startTimer();
          window.scrollTo(0, 0);
        },
      );

      quiz.on("timeout", () => {
        clearTimer();
        // Engine immediately emits next questionShow (or complete) which resets the UI
      });

      quiz.on(
        "optionSelected",
        ({
          index,
          correct,
          correctIndex,
          explanation,
          detailedExplanation,
          references,
          isFinalStage,
          allCorrect,
        }) => {
          clearTimer();
          const buttons = optionsEl.querySelectorAll(".option-btn");
          buttons.forEach((btn, i) => {
            btn.disabled = true;
            if (i === correctIndex) {
              btn.classList.add("correct");
            } else if (i === index && !correct) {
              btn.classList.add("incorrect");
            }
          });

          if (isFinalStage) {
            showFeedback(
              allCorrect,
              explanation,
              detailedExplanation,
              references,
            );
          } else {
            showFeedback(correct, explanation, detailedExplanation, references);
          }
        },
      );

      quiz.on("twoStageAdvance", ({ stageResult, nextStage }) => {
        // Show result on current stage buttons
        const buttons = optionsEl.querySelectorAll(".option-btn");
        buttons.forEach((btn, i) => {
          btn.disabled = true;
          if (i === stageResult.correctIndex) {
            btn.classList.add("correct");
          } else if (i === stageResult.index && !stageResult.correct) {
            btn.classList.add("incorrect");
          }
        });

        // Transition to next stage after delay
        setTimeout(() => {
          const problem = quiz.problem;
          hideAllQuestionTypes();
          optionsEl.innerHTML = "";
          renderTwoStageQuestion(
            problem,
            nextStage.stageIndex,
            nextStage.previousAnswer,
          );
        }, TWO_STAGE_TRANSITION_DELAY);
      });

      quiz.on(
        "numericResult",
        ({
          correct,
          formatted,
          unit,
          explanation,
          detailedExplanation,
          references,
        }) => {
          clearTimer();
          numericInput.disabled = true;
          numericSubmit.disabled = true;
          numericInput.classList.add(correct ? "correct" : "incorrect");

          if (!correct) {
            correctAnswerDisplay.classList.remove("hidden-container");
            correctAnswerValue.textContent =
              formatted + (unit ? " " + unit : "");
          }

          showFeedback(correct, explanation, detailedExplanation, references);
        },
      );

      quiz.on("multiSelectToggle", ({ index, selected }) => {
        const btn = optionsEl.querySelector(`[data-index="${index}"]`);
        btn.classList.toggle("selected", selected);
        btn.setAttribute("aria-pressed", selected.toString());
      });

      quiz.on(
        "multiSelectResult",
        ({
          selected,
          correctIndices,
          correct,
          explanation,
          detailedExplanation,
          references,
        }) => {
          clearTimer();
          const selectedSet = new Set(selected);
          const buttons = optionsEl.querySelectorAll(
            ".option-btn.multi-select",
          );
          buttons.forEach((btn, i) => {
            btn.disabled = true;
            const wasSelected = selectedSet.has(i);
            const shouldBeSelected = correctIndices.includes(i);

            if (wasSelected && shouldBeSelected) {
              btn.classList.add("correct-selected");
            } else if (wasSelected && !shouldBeSelected) {
              btn.classList.add("incorrect-selected");
            } else if (!wasSelected && shouldBeSelected) {
              btn.classList.add("correct-missed");
            }
          });

          multiSubmit.disabled = true;
          multiSubmitContainer.classList.add("hidden-container");
          showFeedback(correct, explanation, detailedExplanation, references);
        },
      );

      quiz.on("orderingUpdate", ({ order }) => {
        updateOrderingDisplay(order);
      });

      quiz.on(
        "orderingResult",
        ({
          userOrder,
          correctOrder,
          correct,
          explanation,
          detailedExplanation,
          references,
        }) => {
          clearTimer();
          const items = orderingItems.querySelectorAll(".ordering-item");
          items.forEach((item) => {
            item.classList.add("disabled");
            item.removeAttribute("tabindex"); // Remove focusability after submit
            const originalIndex = parseInt(item.dataset.originalIndex);

            // For result display, we want to show if this ITEM is in the correct RANK
            // userOrder is the array of originalIndices in visual order.
            // visual index 'i' contains originalIndex 'userOrder[i]'.
            // The correct originalIndex at position 'i' is 'correctOrder[i]'.

            // So for the item visually at 'i', is it the correct item?
            // item.dataset.visualIndex should match i.

            const visualIndex = parseInt(item.dataset.visualIndex);
            const itemOriginalIndex = parseInt(item.dataset.originalIndex);
            const expectedOriginalIndex = correctOrder[visualIndex];

            if (itemOriginalIndex === expectedOriginalIndex) {
              item.classList.add("correct-position");
            } else {
              item.classList.add("incorrect-position");
            }
          });

          orderingSubmit.disabled = true;
          selectedOrderingIndex = -1; // clear selection
          showFeedback(correct, explanation, detailedExplanation, references);
        },
      );

      quiz.on("complete", ({ total, sessionSummary }) => {
        clearTimer();
        clearInProgressSnapshot();
        skipBtn.classList.add("hidden");
        const summary = sessionSummary || quiz.getSessionSummary();
        showResultsView({
          summary,
          isPartial: false,
          answeredCount: total,
          totalProblems: total,
        });

        // Auto-save to localStorage
        sessionHistory.push(summary);
        saveToLocalStorage();
        setResultsExportStatus("Session saved.");

        // Update per-problem tracking
        problemTracking = updateProblemTracking(problemTracking, summary);
        saveProblemTracking();

        // Show dashboard button on results if history exists
        if (sessionHistory.length > 0) {
          resultsDashboardBtn.classList.remove("hidden");
        }
      });

      quiz.on("skip", () => {
        // Engine immediately emits next questionShow which resets the UI
      });

      // =============================================
      // DOM event bindings
      // =============================================

      optionsEl.addEventListener("click", (e) => {
        const btn = e.target.closest(".option-btn");
        if (btn && !btn.disabled) {
          const type = btn.dataset.type || "multiple-choice";
          const index = parseInt(btn.dataset.index, 10);
          if (type === "multi-select") {
            quiz.toggleMultiSelect(index);
          } else {
            quiz.selectOption(index);
          }
        }
      });

      numericSubmit.addEventListener("click", () => {
        quiz.submitNumeric(numericInput.value);
      });

      numericInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          quiz.submitNumeric(numericInput.value);
        }
      });

      orderingItems.addEventListener("click", (e) => {
        const item = e.target.closest(".ordering-item");
        if (!item || item.classList.contains("disabled")) return;

        // Find visual index in the list
        const visualIndex = Array.from(orderingItems.children).indexOf(item);

        if (selectedOrderingIndex === -1) {
          // Select
          selectedOrderingIndex = visualIndex;
          item.classList.add("selected");
          item.setAttribute("aria-pressed", "true");
        } else if (selectedOrderingIndex === visualIndex) {
          // Deselect
          selectedOrderingIndex = -1;
          item.classList.remove("selected");
          item.setAttribute("aria-pressed", "false");
        } else {
          // Swap
          quiz.moveOrderingItem(selectedOrderingIndex, visualIndex);
          // Engine emits orderingUpdate, which we handle to re-render.
          // We want to keep the "selection" following the item?
          // Or clear it?
          // "Tap to select, tap another to swap" -> usually clears selection after swap.
          selectedOrderingIndex = -1;
        }
      });

      orderingItems.addEventListener("keydown", (e) => {
        if (e.target.classList.contains("ordering-item")) {
          const visualIndex = Array.from(orderingItems.children).indexOf(
            e.target,
          );

          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            // Toggle selection
            if (selectedOrderingIndex === visualIndex) {
              selectedOrderingIndex = -1;
              e.target.classList.remove("selected");
              e.target.setAttribute("aria-pressed", "false");
            } else {
              // If something else was selected, assume we want to swap?
              // Or just change selection?
              // Standard "listbox" behavior might be change selection.
              // But for "Swap" model, if I select A, then nav to B and press Enter, I expect Swap.
              if (
                selectedOrderingIndex !== -1 &&
                selectedOrderingIndex !== visualIndex
              ) {
                quiz.moveOrderingItem(selectedOrderingIndex, visualIndex);
                selectedOrderingIndex = -1;
              } else {
                selectedOrderingIndex = visualIndex;
                e.target.classList.add("selected");
                e.target.setAttribute("aria-pressed", "true");
              }
            }
          } else if (e.key === "ArrowUp") {
            // If selected, Move. If not, standard focus (handled by browser usually, but we might need to help).
            // Actually standard focus nav doesn't work automatically for divs unless we handle it
            // or they are in a container that manages it.
            // Let's implement focus nav + move.
            e.preventDefault();

            if (selectedOrderingIndex === visualIndex) {
              // Move Logic
              if (visualIndex > 0) {
                quiz.moveOrderingItem(visualIndex, visualIndex - 1);
                selectedOrderingIndex = visualIndex - 1; // Follow the item
              }
            } else {
              // Focus Logic
              const prev = orderingItems.children[visualIndex - 1];
              if (prev) prev.focus();
            }
          } else if (e.key === "ArrowDown") {
            e.preventDefault();
            if (selectedOrderingIndex === visualIndex) {
              // Move Logic
              if (visualIndex < orderingItems.children.length - 1) {
                quiz.moveOrderingItem(visualIndex, visualIndex + 1);
                selectedOrderingIndex = visualIndex + 1; // Follow the item
              }
            } else {
              // Focus Logic
              const next = orderingItems.children[visualIndex + 1];
              if (next) next.focus();
            }
          }
        }
      });

      orderingSubmit.addEventListener("click", () => {
        quiz.submitOrdering();
      });

      multiSubmit.addEventListener("click", () => {
        quiz.submitMultiSelect();
      });

      nextBtn.addEventListener("click", () => {
        quiz.next();
      });

      skipBtn.addEventListener("click", () => {
        quiz.skip();
      });

      copyJsonBtn.addEventListener("click", () => {
        copySummaryJsonToClipboard();
      });

      showSummaryBtn.addEventListener("click", () => {
        toggleSummaryView();
      });

      retryBtn.addEventListener("click", () => {
        results.classList.remove("active");
        practice.classList.add("active");
        quiz.retry();
      });

      backBtn.addEventListener("click", backToMenu);
      quitBtn.addEventListener("click", () => {
        if (quiz.state !== "practicing" && quiz.state !== "answered") {
          backToMenu();
          return;
        }

        const summary = quiz.getSessionSummary();
        const answeredCount = summary.score.total;
        const totalProblems = quiz.progress.total;
        showResultsView({
          summary,
          isPartial: true,
          answeredCount,
          totalProblems,
        });
      });

      // Dashboard & history event bindings
      dashboardBtn.addEventListener("click", () => {
        showDashboard();
      });

      loadHistoryBtn.addEventListener("click", () => {
        importArea.classList.remove("hidden-container");
        historySection.classList.add("hidden-container");
        importTextarea.value = "";
        importStatus.textContent = "";
        importTextarea.focus();
      });

      importSubmitBtn.addEventListener("click", () => {
        const result = loadHistoryFromPaste(importTextarea.value);
        if (result.errors.length > 0 && result.imported === 0) {
          importStatus.textContent = `No sessions imported. ${result.errors[0]}`;
        } else if (result.errors.length > 0) {
          importStatus.textContent = `Imported ${result.imported} session${result.imported !== 1 ? "s" : ""} (${result.errors.length} invalid).`;
        } else {
          importStatus.textContent = `Imported ${result.imported} session${result.imported !== 1 ? "s" : ""}.`;
        }
      });

      importCancelBtn.addEventListener("click", () => {
        importArea.classList.add("hidden-container");
        renderHistorySummary();
      });

      dashboardBackBtn.addEventListener("click", () => {
        hideDashboard();
      });

      exportAllBtn.addEventListener("click", () => {
        exportAllHistory();
      });

      clearHistoryBtn.addEventListener("click", () => {
        clearHistory();
      });

      resultsDashboardBtn.addEventListener("click", () => {
        showDashboard();
      });

      // Resume prompt event bindings
      resumeYesBtn.addEventListener("click", () => {
        const snapshot = loadInProgressSnapshot();
        if (!snapshot) return;
        quiz.restoreSession(snapshot);

        // Show practice view with saved context
        const ctx = snapshot.context || {};
        const title = ctx.chapterTitle || ctx.unitTitle || "Resumed Session";
        const answered = snapshot.answers.length;
        const total = snapshot.problems.length;
        const description = `Resuming: ${answered} of ${total} answered`;

        landing.classList.add("hidden");
        results.classList.remove("active");
        practice.classList.add("active");
        practiceTitle.textContent = title;
        chapterDesc.textContent = description;

        quiz.resume();
        clearInProgressSnapshot();
      });

      resumeNoBtn.addEventListener("click", () => {
        clearInProgressSnapshot();
        resumePrompt.classList.add("hidden-container");
      });

      // Save in-progress state on page unload
      window.addEventListener("beforeunload", () => {
        const state = quiz.state;
        if (state === "practicing" || state === "answered") {
          saveInProgressSnapshot(quiz.getSnapshot());
        } else {
          clearInProgressSnapshot();
        }
      });

      // =============================================
      // Initialize
      // =============================================

      document.title = CONFIG.title;
      document
        .querySelector('meta[name="description"]')
        .setAttribute("content", CONFIG.description);
      document.getElementById("landing-title").textContent = CONFIG.title;
      document.getElementById("landing-description").textContent =
        CONFIG.description;
      if (CONFIG.backLink) {
        const link = document.createElement("a");
        link.href = CONFIG.backLink.href;
        link.className = "back-link";
        link.textContent = CONFIG.backLink.text;
        document.getElementById("back-link-container").appendChild(link);
      }

      renderUnitList();
      sessionHistory = loadFromLocalStorage();
      problemTracking = loadProblemTracking();
      renderHistorySummary();

      // Check for in-progress snapshot to offer resume
      const savedSnapshot = loadInProgressSnapshot();
      if (
        savedSnapshot &&
        savedSnapshot.problems &&
        savedSnapshot.problems.length > 0
      ) {
        const ctx = savedSnapshot.context || {};
        const title = ctx.chapterTitle || ctx.unitTitle || "Previous session";
        const answered = savedSnapshot.answers
          ? savedSnapshot.answers.length
          : 0;
        const total = savedSnapshot.problems.length;
        resumePromptText.textContent = `Resume "${title}"? (${answered}/${total} answered)`;
        resumePrompt.classList.remove("hidden-container");
      }
    </script>
  </body>
</html>
